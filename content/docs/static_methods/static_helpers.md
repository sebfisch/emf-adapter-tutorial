---
title: Static Helpers
weight: 16
---

# Static methods with additional functionality

There many opions for how to implement additional functionality for the types in our game-state model.
We could

1. modify the source code generated by EMF,
2. use inheritance to extend the generated interfaces,
3. define static methods operating on model types, or
4. use delegation to operate on wrapped model instances.

This tutorial is about learning to do option 4 with EMF adapters. However, the first version of the Tic-Tac-Toe app does not yet use adapters.
It uses option 3, defining static helpers, that will be contrasted with adapters in the next part of the tutorial.

[game.helpers package]: https://github.com/sebfisch/emf-adapter-tutorial-code/tree/step1-static-methods-v1/de.sebfisch.tictactoe/src/game/helpers

The [game.helpers package] contains classes with static methods for `Board` and `Field` instances.

## Board helpers

We already saw the method `BoardHelpers.getComponent` which creates a user-interface component representing a `Board` instance with a 3x3 grid of field components.

```java
// game.helpers.BoardHelpers
public static JComponent getComponent(final Board board) {
	final JPanel panel = new JPanel();
	panel.setLayout(new GridLayout(GRID_SIZE, GRID_SIZE));
	board.getFields().forEach(field -> {
		FieldHelpers.addUnmarkedFieldComponent(field, panel);
	});
	return panel;
}
```

[consumers]: ../../background/functional_interfaces#consumers

The call to `forEach` is another example for a lambda expression. This one is converted into an instance of the `Consumer` interface.
You can learn more about [consumers] in a background section.

Another method (that we will see being used later when marking fields) replaces one of the unmarked field components with a different component.

```java
// game.helpers.BoardHelpers
public static void
replaceChild(final JComponent parent, final int index, final JComponent child) {
	parent.remove(index);
	parent.add(child, index);
	parent.revalidate();
	parent.repaint();
}
```

## Field helpers

The user-interface components for unmarked `Field` instances are created in a static method of the class `FieldHelpers`.

```java
// game.helpers.FieldHelpers
public static void
addUnmarkedFieldComponent(final Field field, final JComponent parent) {
	final JButton button = new JButton("");
	button.setPreferredSize(FIELD_DIMENSIONS);
	button.addActionListener(_event -> {
		makeMoveAt(field);
		updateMark(field, parent);
	});
	parent.add(button);
}
```

This method creates an empty button representing an unmarked field.
Apart from a `Field` instance, this method takes the parent component as second argument.
The button is added to the parent component in the end, but the parent component is also passed to the `updateMark` method in an action listener for the created button.

When pressing the button, the game-state is modified by the call `makeMoveAt(field)` which places a mark of the current player on the given `field` and switches the current player.

```java
// game.helpers.FieldHelpers
public static void makeMoveAt(final Field field) {
	final Board board = field.getBoard();
	final Player player = board.getCurrentPlayer();
	field.setMark(GameConstructors.markFor(player));
	board.setCurrentPlayer(Player.X.equals(player) ? Player.O : Player.X);
}
```

[game constructors]: https://github.com/sebfisch/emf-adapter-tutorial-code/blob/step1-static-methods-v1/de.sebfisch.tictactoe/src/constructors/GameConstructors.java

The method `markFor` in the [game constructors] class creates an instance of `Mark` with the given `player`.
After the game state is modified, the method `updateMark` queries it and adjusts the user interface accordingly.

```java
// game.helpers.FieldHelpers
public static void updateMark(final Field field, final JComponent parent) {
	getMarkingPlayer(field).ifPresent(player -> {
		final JComponent child =
			UiConstructors.boldLabel(player.toString(), LABEL_SIZE);
		BoardHelpers.replaceChild(parent, field.getIndex(), child);
	});
}
```

[user interface constructors]: https://github.com/sebfisch/emf-adapter-tutorial-code/blob/step1-static-methods-v1/de.sebfisch.tictactoe/src/constructors/UiConstructors.java

This method replaces the button for the given `field` in the `parent` component with a label created by `boldLabel` in the [user interface constructors] class.
The method `getMarkingPlayer` queries the `Player` that marked the given field, if there is a mark.

```java
// game.helpers.FieldHelpers
public static Optional<Player> getMarkingPlayer(final Field field) {
	return Optional.ofNullable(field.getMark()).map(Mark::getPlayer);
}
```

[type parameter]: ../../background/type_parameters#optional-values
[method reference]: ../../background/functional_interfaces#method-references

As not every `Field` is necessarily marked by a player, the result of this method is of the `Optional` type.
`Optional` is an example of a type with a [type parameter].
Its `map` method takes an instance of the `Function` interface which we instantiate here using a so called [method reference].
Follow the links to read more about the parameterized `Optional` type or method references in the background section.

## Code Review

The presented helper methods can be grouped into different categories.
The board helpers are all related to the user interface component representing a board.
From the field helpers, two are concerned with the user interface and two are concerned with querying or modifying the game state.
Methods in one group may call methods in other groups.
For example, `updateMark` is a field helper concerned with the user interface which calls a field helper concerned with the game state and a board helper concerned with the user interface.

It would be beneficial to restructure the implemented functionality to have a more clear separation between accessing the game state and managing the user interface.
This restructuring should be done in a way that still supports cross references where necessary.

In order to replace the user interface for an unmarked field with a mark, the user interface component representing the board is passed as argument to several helper methods.
From the corresponding method signatures it is not immediately clear that the `parent` component is always the board representation.
In fact, the methods could be called with different `parent` components as arguments with possibly inintended results.

It would be beneficial to associate the user interface component representing the board with the board it represents to avoid such confusion.

The update of the user interface of fields is triggered directly by the button representing unmarked fields.
As a consequence, alternative updates of the game state (for example, when implementing a computer opponent) would not be reflected in the user interface automatically.

It would be beneficial to trigger the user interface update as a reaction to arbitrary game-state modifications of marks in fields to decouple the user interface update from specific actions that cause marks to change.

In the [next part] of this tutorial we will refactor the Tic-Tac-Toe app to implement the suggested improvements using EMF adapters.

[next part]: ../../plain_adapters
